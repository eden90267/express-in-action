# chap12. 最佳實踐

>**本章涵蓋**  
>簡化你代碼的好處  
>結構化你的app文件  
>使用`npm shrinkwrap`命令來鎖定可靠的依賴項版本(以及這樣做的好處)  
>避免全局模組的安裝

## 簡潔

很多維護大型代碼庫的最佳實踐，歸納為一件事情：簡潔。你的代碼應該是易於其他開發者觀看的，你需要盡量的減少一個人所要記住的上下文。

為了理解Express，你做了很多的了解：

- 為了閱讀代碼，你理應對Javascript編程語言十分的了解
- 你必須了解HTTP的工作方式而對路由進行理解
- 你必須了解Node以及它的事件I/O
- 你必須了解Express的路由、中間件、視圖，以及它的特性

應用程式應該盡可能少的引入一大堆需要了解的東西。

透過這兩個方法可以看看你代碼的兔子洞到底有多深：

- 查看你的一段代碼──可以是一個路由處理或是中間件函數──然後詢問自己需要多少的額外知識才能了解這段代碼。
- 跟你一起的開發人員有多困惑? 他們為你的app添加一個特性需要多久?如果他們覺得很困惑且不能快速的工作，這就意味著你的代碼有點太複雜了。

你必須嚴格的做到簡潔。我們將在本章討論一些方法。

## 文件結構模式

![](http://i.imgur.com/MlOChi8.png)

這些是一個Express應用程序結構中常見的文件：

- package.json
- app.js編寫我們應用程序的重要代碼─入口點。在這裡你調用express()來實例化一個Express應用程序。這裡同樣也放置所有路由的通用中間件，例如安全中間件和靜態文件中間件。如你所見，**這個文件並不會啟動app**─它只是將app分配到了`module.exports`。
- bin文件夾存放了你應用程序的所有可執行腳本。裡面通常只會有一個文件，但有時會引入更多。

    bin/www是一個可執行的Node腳本，它(從app.js)`require`了你的app並啟動它。並在調用`npm start`的時候運行這個腳本。

- config是一個包含你app所有配置的文件夾。裡面通常會有很多的JSON文件，這些文件通常會指定一些默認端口號或本地化字符串這樣的東西。
- public是一個用於給靜態文件中間件服務的文件夾。裡面將會存放任何類型的靜態文件─HTML頁面、text文件、圖片、視頻等等。這個靜態文件中間件同樣可以提供一些公共文件夾。例如，[https://html5boilerplate.com/](https://html5boilerplate.com/)中的HTML 5 Boilerplate，提供一個很好的選擇，你可以在這裡添加常規的靜態文件。
- routes文件夾存放眾多的JavaScript文件，每一個文件都輸出了一個Express的Router。

    你可能有一個用來處理所有以/users開頭的URL Router，或另一個用來處理所有以/photos開頭的URL Router。

- test文件夾存放了你所有的測試代碼。
- views文件夾存放你所有的視圖文件。

一個查看這種文件組織方式優勢的最後方法就是，使用官方的Express應用程序生成器，你可利用npm i -g express-generator來進行安裝。一旦你安裝了她，你就可以運行express my-new-app，它就會創建一個my-express-app文件夾並在裡面設置app骨架。

這樣的模式和慣例會很常見。

## 鎖定依賴項版本

默認情況下，當你用`npm install --save`安裝一個包的時候，就會從npm倉庫下載最新版本的包，接著會在你的package.json文件中放置一個積極版本號。這就意味著，如果你團隊中的其他人(或者你自己想再次安裝)在這個項目中運行`npm install`，這個時候他們獲得的版本可能會比你最初下載的版本要新一些。這個較新的版本可能會有一個更高的副版本或更高的補丁版本，但是卻不會獲取更高的主版本。這意味著它下載的包版本不會是絕對最新的；它會下載可兼容的最新版本：

![](http://i.imgur.com/Th8NyeI.png)

一切安好，不是嗎？如果所有的包都附帶了語意化版本，你應該總是獲取最新的適配技術，從而讓你可以得到所有最新的特性和最新的bug修復。

但是這樣有個難點：並不是所有的包都完美遵循語意化版本。通常，因為人們使用包的方式並沒有遵循原始開發者的意圖。而且沒有任何一個開發者擁有無bug紀錄，尤其是在別的開發者不按照他們預期來使用代碼的時候。

我發現大多數時候這並不是問題。我使用的模組通常有良好的語意化版本，並且npm積極版本可以工作良好。但當我部署一個重要業務應用到生產環境，我喜歡鎖定我的依賴項版本從而減少任何潛在的問題！

有兩個鎖定版本的方法：其中一個方法很簡單但並不徹底，而另一個方法卻是十分徹底的。

### 簡單的方法：避免使用積極版本

一個快捷的方法就是清除你package.json的積極版本。

```
// ...
"dependencies": {
  "express": "^4.0.0",
  "ejs": "~2.3.2"
}
// ...
```

`＾`符號表示允許使用積極版本。你會獲取到所有的補丁和父版本的更新。`~`符號表示進行較小幅度的積極版本變化。你將只會獲得補丁的更新。

如果你要編輯`package.json`，可以以把依賴項指定為一個特定版本：

```
// ...
"dependencies": {
  "express": "4.0.0",
  "ejs": "2.3.2"
}
// ...
```

從版本號移除`^`和`~`符號後指定的就是需要下載和使用的特定包版本了。編輯這些可以相對簡單的鎖定一個特定的版本。

如果你安裝一個新的包，你可以將`--save`替換為`--save-exact`來關閉積極版本的使用。這樣總會指定一個特定版本。

這個簡單的方法有一個缺點：它不會限制子控制項(你依賴項的依賴項)的版本。下面的代碼清單展示了Express的依賴樹：

```
your-express-app@0.0.0
└─┬ express@5.0.0
  ├─┬ accepts@1.2.12
  │ ├─┬ mime-types@2.1.6
  │ │ └── mime-db@1.18.0
  │ └── negotiator@0.5.3
  ├── array-flatten@1.1.0
  ├── content-disposition@0.5.0
  ├── content-type@1.0.1
  ├── cookie@0.1.3
  ├── cookie-signature@1.0.6
  ├─┬ debug@2.2.0
  │ └── ms@0.7.1
  ├── depd@1.0.1
  ├── escape-html@1.0.2
  ├── etag@1.7.0
  ├─┬ finalhandler@0.4.0
  │ └── unpipe@1.0.0
  ├── fresh@0.3.0
  ├── merge-descriptors@1.0.0
  ├── methods@1.1.1
  ├─┬ on-finished@2.3.0
  │ └── ee-first@1.1.1
  ├── parseurl@1.3.0
  ├── path-is-absolute@1.0.0
  ├── path-to-regexp@0.1.6
  ├─┬ proxy-addr@1.0.8
  │ ├── forwarded@0.1.0
  │ └── ipaddr.js@1.0.1
  ├── qs@4.0.0
  ├── range-parser@1.0.2
  ├─┬ router@1.1.3
  │ ├── array-flatten@1.1.1
  │ ├── path-to-regexp@0.1.7
  │ └── setprototypeof@1.0.0
  ├─┬ send@0.13.0
  │ ├── destroy@1.0.3
  │ ├─┬ http-errors@1.3.1
  │ │ └── inherits@2.0.1
  │ ├── mime@1.3.4
  │ ├── ms@0.7.1
  │ └── statuses@1.2.1
  ├── serve-static@1.10.0
  ├─┬ type-is@1.6.8
  │ ├── media-typer@0.3.0
  │ └─┬ mime-types@2.1.6
  │   └── mime-db@1.18.0
  ├── utils-merge@1.0.0
  └── vary@1.0.1
```

依賴項的依賴項若指定為積極版本，在我對包進行重新安裝，會自動更新版本，這多麽的危險啊！

某天依賴樹是這樣：

```
your-express-app@0.0.0
└─┬ backbone@1.2.3
  └── underscore@1.0.0
```

但之後某天可能看起來就這樣：

```
your-express-app@0.0.0
└─┬ backbone@1.2.3
  └── underscore@1.1.0
```

注意到Underscore的版本有些不同。

利用這方法，沒有辦法可以保證你的子依賴項(或子子依賴項，等等)可以被控制，這可能是好的，也可能是不好的。如果這並不好，你就可以使用npm中被稱為收縮包裝個特性。

### 徹底的方法：npm的收縮包裝命令

前一個解決問題的方法並不能鎖定子依賴項的版本。npm有一個叫做shrinkwrap的子命令可以解決這個問題。

假設你運行npm install並且一切運行良好。這個時候就會想鎖定你的依賴項。這時候你在項目中運行一個命令：

```
npm shrinkwrap
```

你可在任何擁有pakcage.json文件和依賴項的Node項目中運行這個命令。如果一切運行良好，將會輸出一行：`wrote npm-shrinkwrap.json`。

你會看到一個列表包含了依賴項、版本，以及這些依賴項的依賴項，等等。`npm-shrinkwrap.js`：

```
{
  "dependencies": {
    "express": {
      "version": "5.0.0",
      // ...
      "dependencies": {
        "accepts": {
          "version": "1.2.12",
          // ...
          "dependencies": {
            "mime-types": {
              "version": "2.1.6",
              // ...
             "dependencies": {
               "mime-db": {
                 "version": "1.18.0",
                  // ...
                }
              }
            },
            "negotiator": {
              "version": "0.5.3",
              // ...
            }
          }
        },
        // ...
```

你最應該注意到的應該是整個依賴樹版本都是特定的，這跟package.json的頂層並不相似。

下次你用`npm install`安裝的時候，它並不會查看*package.json*——它將會查看*npm-shrinkwrap.json*並安裝到那裡。

跟package.json一樣，你通常會透過檢查*npm-shrinkwrap.json*來做版本控制。它允許所有開發者在這個項目中保持一致的包版本，這就是whrink-wrapping的目的！

### 升級和添加依賴項

為了更新或添加一個依賴項，你需要帶著包版本號來運行npm install。例如：`npm install express@4.12`。新的包：`npm install helmet`。這會更新它的版本或添加這個包到你的node_modules文件夾，同時你將可啟動測試。一旦運作良好，你就可以再次運行`npm shrinkwrap`來鎖定依賴項的版本了。

## 局部依賴項

全局安裝Grunt會導致兩個問題：

- 一個新開發者的電腦中可能並沒有安裝Grunt。這就意味著你需要在README或其他文件中提醒他們安裝Grunt。
- 是否他們安裝了錯誤版本的Grunt？你可想像他們安裝了太老或太新的版本，從而導致無法追蹤的奇怪問題。

這裡有一個解決這兩個問題的簡單方式：將Grunt作為依賴項安裝到你的項目中，而不是採用全局安裝的方式。

mocha測試框架我們就將它本地安裝到我們的項目中。它就會在*node_modules/.bin/mocha*安裝一個mocha可執行命令，你可直接執行它或把它添加到npm腳本中。

### 直接調用命令

最簡單方式就是直接調用命令。雖然要輸入很多東西：在命令行中輸入這個命令的路徑。

- mocha：`node_modules/.bin/mocha`
- bower：`node_modules/.bin/bower`

### 用npm腳本來執行命令

另一個方法，就是把命令添加為一個npm腳本。

```
// ...
"scripts": {
    "test": "mocha"
}
// ...
```

當你輸入`npm test`，mocha命令就會神奇般的運行。以下圖片解釋工作流程：

![](http://i.imgur.com/SEykGyX.png)

這通常在你一遍又一遍的運行重複命令的時候很有幫助。它同樣讓你的依賴項遠離了全局安裝。

## 總結

簡單性通常是一個軟件高層次的目標。你應該嚴格的從你軟件中移除複雜的東西。

在很多Express應用程序中通常會出現同一個文件夾和文件結構。

為了最大程度地獲得可靠性，你需要鎖定你依賴項的版本。這樣做會有一個缺點——也就是說，你並不能自動的運行最新最好的代碼——不過他的優勢就是，你的代碼不會在你不知情的情況下自動更新。

本地安裝依賴項可以讓你的**系統保持整潔**，同時讓你的**項目更加的可靠**。你可以使用npm腳本做到這點。

是時候用Express來編寫一些酷炫的東西了！